#!/usr/bin/env ruby
require File.expand_path('../lib/client',                          File.dirname(__FILE__))
require File.expand_path('../lib/parser/adapters/thor',            File.dirname(__FILE__))
require File.expand_path('../lib/commands/thor/dtk',               File.dirname(__FILE__))
require File.expand_path('../lib/error',                           File.dirname(__FILE__))
require File.expand_path('../lib/shell/context',                   File.dirname(__FILE__))

require 'shellwords'
require 'readline'
require 'thor'
require 'rubygems'
require 'active_support/core_ext/string/inflections'

#ideas from http://bogojoker.com/readline/#trap_sigint_and_restore_the_state_of_the_terminal

# client commands
CLIENT_COMMANDS   = ['cc','exit','clear']
DTK_ROOT_PROMPT   = "dtk:/>"
@context    = DTK::Shell::Context.new
@current_cc = []

# METHODS

 # check if command is valid for current context, only on tier 1 commands
 # also checks is ID/NAME valid
def validate_command(command)

  if @current_cc.empty?
    unless @current_context.include? command
      raise DTK::Shell::Error, "Context '#{command}' not present for current tier."
    end
  else
    # at the moment this is tier 2
    unless @context.valid_id?(@current_cc.first,command)
      raise DTK::Shell::Error, "#{@current_cc.first.capitalize} identifier '#{command}' is not valid."
    end
  end
end

def reset_context
  @current_cc = []
  load_context
end


def change_context(args)
  return DTK_ROOT_PROMPT if args.empty?

  # if separated by spaces join them with '/' so we support spaces and slashes
  if args.instance_of?(Array) && args.size > 1
    args = args.join('/')
  end

  # first command is the one we take context from
  command = args.first

  # check for root of context
  if '/'.eql?(command[0,1])
    reset_context()
    next_command = command[1,command.size]
    return change_context(next_command)
  end

  # for multi context e.g. `cc library/public`
  if command.include?('/')
    context_commands = command.split('/')
    # last command will continue to run in this flow
    command = context_commands.pop
    # use recursion to load all other commands first, second, ...
    context_commands.each { |context_comm| change_context(context_comm) }
    # flow will continue with last command left to load (see above)
  end
    
  if command.match(/\.\.[\/]?/)
    # backtracing context
    @current_cc.pop
    command = @current_cc.last
  else 
    # validates command
    validate_command(command)
    # set command to context
    @current_cc << command
  end

  # loads context for given command
  load_context(command)

  return "dtk:/#{@current_cc.join('/')}>"
end

def load_context(command_name=nil)
  # defa ult to existing context if there is no new one
  @current_context = @context.sub_tasks_names(command_name) || @current_context
  Readline.completion_append_character = " "
  comp = proc { |s| @current_context.concat(CLIENT_COMMANDS).sort.grep( /^#{Regexp.escape(s)}/ ) }
  Readline.completion_proc = comp
end

def reverse_commands(cmd, args)
  # changes command and argument if argument is plural of one of 
  # the possible commands on tier1 e.g. libraries, assemblies
  @current_context.each do |current|
    command_singular=args.first.singularize
    if current.eql?(command_singular)
      cmd, args = command_singular, [cmd]
    end
  end

  return cmd, args
end

# RUNTIME PART

# load tier 1 context 
load_context('dtk')

prompt = 'dtk:/> '
while line = Readline.readline(prompt, true)
  begin
    # some special cases
    exit if line == 'exit'
    next if line.empty?
    system('clear') and next if line == 'clear'
    # when using help on root this is needed
    line = 'dtk' if (line == 'help' && @current_cc.empty?)

    args = Shellwords.split(line)
    cmd = args.shift

    temp_dev_flag = true

    if ('cc' == cmd)
      prompt = change_context(args)
    else
      # if e.g "list libraries" is sent instead of "library list" we reverse commands
      # and still search for 'library list', this happens only on root
      if !args.empty? && @current_cc.empty?
        cmd, args = reverse_commands(cmd, args)
      end

      # if there is no set context no need to pre-process command
      unless @current_cc.empty?
        # command goes as first argument
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
        args.unshift(cmd)
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
        # main command is first one from @current_cc
        cmd  = @current_cc.first

        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
        # in case there is second cc it means it is ID and goes as first arg
        args.unshift(@current_cc.last) if @current_cc.size > 1
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
      end


      puts "Command > #{cmd} #{args.join(' ')}" if temp_dev_flag

      # execute command via Thor
      top_level_execute(cmd,args,true)
    end


   
   rescue DTK::Shell::Error => e
    puts e.message
   rescue Interrupt => e
    system('stty', stty_save) # Restore
    exit
  end
end

