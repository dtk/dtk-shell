#!/usr/bin/env ruby
require File.expand_path('../lib/client',                  File.dirname(__FILE__))
require File.expand_path('../lib/parser/adapters/thor',    File.dirname(__FILE__))
require File.expand_path('../lib/commands/thor/dtk',       File.dirname(__FILE__))
require File.expand_path('../lib/error',                   File.dirname(__FILE__))

# load all from shell directory since those are required
Dir[File.expand_path('../lib/shell/*.rb', File.dirname(__FILE__))].each {|file| require file }

require 'shellwords'
require 'readline'
require 'thor'
require 'rubygems'

#ideas from http://bogojoker.com/readline/#trap_sigint_and_restore_the_state_of_the_terminal

# GLOBAL IDENTIFIER
$shell_mode = true
ALIAS_COMMANDS = {
  'ls' => 'list', 
  'cd' => 'cc',
  'rm' => 'delete'
}

# METHODS

def change_context(args)
  return DTK::Shell::Context::DTK_ROOT_PROMPT if args.empty?

  begin
    # if separated by spaces join them with '/' so we support spaces and slashes
    if args.instance_of?(Array) && args.size > 1
      args = args.join('/')
    end

    # first command is the one we take context from
    command = args.first

    # check for root of context
    if '/'.eql?(command[0,1])
      @context.reset()
      next_command = command[1,command.size]
      return change_context(next_command)
    end

    # for multi context e.g. `cc library/public`
    if command.include?('/')
      multiple_commands = command.split('/')
      # last command will continue to run in this flow
      command = multiple_commands.pop
      # use recursion to load all other commands first, second, ...
      # flow will continue with last command left to load (see above)
      multiple_commands.each { |m_command| change_context(m_command) }
      # ...
    end
      
    if command.match(/\.\.[\/]?/)
      # backtracing context
      @context.remove_last_command
      # since we support two level max this will be tier 1 command or root
      command = @context.tier_1_command
    else 
      # validates command
      @context.command_valid?(command)
      # set command to context
      @context.insert_active_command(command)
    end

    # loads context for given command
    @context.load_context(command)

  rescue DTK::Shell::Error => e
    puts e.message
  ensure
    return @context.shell_prompt
  end
end

# support for alias commands (ls for list etc.)
def preprocess_commands(original_command)
  command = ALIAS_COMMANDS[original_command]
  # return command if alias for specific command exist in predefined ALIAS_COMMANDS
  # else return entered command because there is no alias for it
  return (command.nil? ? original_command : command)
end
# RUNTIME PART - STARTS HERE

begin
  @context      = DTK::Shell::Context.new
  @shell_header = DTK::Shell::HeaderShell.new
  # loads root context 
  @context.load_context()
rescue DTK::Client::DtkError => e
  puts e.message
  exit
end

@t1 = nil

prompt = DTK::Shell::Context::DTK_ROOT_PROMPT

begin
  while line = Readline.readline(prompt, true)
    begin
      # some special cases
      exit if line == 'exit'
      next if line.empty?
      system('clear') and next if line == 'clear'
      # when using help on root this is needed
      line = 'dtk' if (line == 'help' && @context.root?)

      args = Shellwords.split(line)
      cmd = args.shift

      # support command alias (ls for list etc.)
      cmd = preprocess_commands(cmd)
      
      if ('cc' == cmd)
        # in case there is no params we just reload command
        args << "/" if args.empty?
        # changes context based on passed args
        prompt = change_context(args)
      else
        # if e.g "list libraries" is sent instead of "library list" we reverse commands
        # and still search for 'library list', this happens only on root
        if !args.empty? && @context.active_commands.empty?
          cmd, args = @context.reverse_commands(cmd, args)
        end

        # we only pre-process commands on Tier 1, Tier 2 on root there is no need
        unless @context.root?
          # command goes as first argument
          args.unshift(cmd)
          # main command is first one from 
          cmd  = @context.tier_1_command()
          # in case there is second cc it means it is ID and goes as first arg
          args.unshift(@context.tier_2_command()) if @context.tier_2?
        end

        temp_dev_flag = true
        puts "dtk-input > #{cmd} #{args.join(' ')}" if temp_dev_flag

        # special case when we are doing help for context we need to remove
        # context paramter
        if @context.tier_2?
          if args.last == 'help'
            # we remove ID/NAME in order for help command to work
            # e.g. library public help => library help
            args.shift
          end
        end

        # send monkey patch class information about context
        Thor.set_context(@context)

        # execute command via Thor
        top_level_execute(cmd,args,true)

        # when 'delete' or 'delete-and-destroy' command is executed reload cached tasks with latest commands
        unless (args.nil? || args.empty?)
          @context.reload_cached_tasks(cmd) if args.first.include?('delete')
        end

        # check execution status, prints status to sttout
        DTK::Shell::StatusMonitor.check_status()
      end

    rescue DTK::Shell::Error => e
      puts e.message
    end
  end
rescue Interrupt => e
  #system('stty', stty_save) # Restore
  puts
  exit
end



