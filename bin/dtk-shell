#!/usr/bin/env ruby
require File.expand_path('../lib/client', File.dirname(__FILE__))
require File.expand_path('../lib/parser/adapters/thor', File.dirname(__FILE__))
require File.expand_path('../lib/commands/thor/dtk', File.dirname(__FILE__))
require File.expand_path('../lib/commands/thor/assembly_template', File.dirname(__FILE__))
require File.expand_path('../lib/error', File.dirname(__FILE__))
require File.expand_path('../lib/shell/context', File.dirname(__FILE__))

require 'shellwords'
require 'readline'
require 'thor'
require 'rubygems'
require 'active_support/core_ext/string/inflections'

#ideas from http://bogojoker.com/readline/#trap_sigint_and_restore_the_state_of_the_terminal

# client commands
CLIENT_COMMANDS   = ['cc','exit','clear']
DTK_ROOT_PROMPT   = "dtk:/>"
@context    = DTK::Shell::Context.new
@current_cc = []

# METHODS

def change_context(args)
  return DTK_ROOT_PROMPT if args.empty?

  # if separated by spaces join them with '/' so we support spaces and slashes
  if args.instance_of?(Array) && args.size > 1
    args = args.join('/')
  end

  # first command is the one we take context from
  command = args.first

  # check for root of context
  if '/'.eql?(command[0,1])
    @current_cc = []
    return change_context(command[1,command.size])
  end

  # for multi context e.g. `cc library/public`
  if command.include?('/')
    context_commands = command.split('/')
    # last command will continue to run in this flow
    command = context_commands.pop
    # use recursion to load all other commands first, second, ...
    context_commands.each { |context_comm| change_context(context_comm) }
    # flow will continue with last command left to load
  end

  if '..'.eql?(command)
    # backtracing context
    @current_cc.pop
    command = @current_cc.last
  else 
    # set commnad to context
    @current_cc << command
  end

  # check if command is valid for current context, only on tier 1 commands
  # unfortunatly we need to stop there since there is no way to detect if 
  # ID/NAME is valid for now
  if @tier_1
    unless @current_context.include? command
      raise DTK::Shell::Error, "Context '#{command}' not present for current tier."
    end
  end

  # loads context for given command
  load_context(command)

  return "dtk:/#{@current_cc.join('/')}>"
end

def load_context(command_name)
  @tier_1 = (command_name == 'dtk')
  # default to existing context if there is no new one
  @current_context = @context.sub_tasks_names(command_name) || @current_context
  Readline.completion_append_character = " "
  comp = proc { |s| CLIENT_COMMANDS.concat(@current_context).sort.grep( /^#{Regexp.escape(s)}/ ) }
  Readline.completion_proc = comp
end

# RUNTIME PART
def reverse_commands(cmd, args)
  @current_context.each do |current|
    command_singular=args.first.singularize
    if current.eql?(command_singular)
      cmd, args = command_singular, [cmd]
    end
  end

  return cmd, args
end

# load tier 1 context 
load_context('dtk')

prompt = 'dtk:/> '
while line = Readline.readline(prompt, true)
  begin
    exit if line == 'exit'
    next if line.empty?
    system('clear'); next if line == 'clear'

    args = Shellwords.split(line)
    cmd = args.shift

    # if e.g "list libraries" is sent instead of "library list" we reverse commands
    # and still search for 'library list'
    unless args.empty?
      cmd, args = reverse_commands(cmd, args)
    end

    temp_dev_flag = true

    if ('cc' == cmd)
      prompt = change_context(args)
    else
      # if there is no set context no need to pre-process command
      unless @current_cc.empty?
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
        # command goes as first argument
        args.unshift(cmd)
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
        # main command is first one from @current_cc
        cmd  = @current_cc.first
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
        # in case there is second cc it means it is ID and goes as first arg
        args.unshift(@current_cc.last) if @current_cc.size > 1
        puts "CC: #{@current_cc}, CMD: #{cmd}, ARGS: #{args}" if temp_dev_flag
      end

      puts "Command > #{cmd} #{args.join(' ')}" if temp_dev_flag

      # execute command via Thor
      top_level_execute(cmd,args)
    end

   
   rescue DTK::Shell::Error => e
    puts e.message
   rescue Interrupt => e
    system('stty', stty_save) # Restore
    exit
  end
end

